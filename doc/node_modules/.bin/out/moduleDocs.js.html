<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: moduleDocs.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: moduleDocs.js</h1>

    



    
    <section>
        <article>
<<<<<<< HEAD
            <pre class="prettyprint source linenums"><code>//
// VIDAMO module, open for editing by Module Developer
//



	/*
	 *
	 * General Functions,
	 * Input - according to requirements; Output - non-geometric primitives
	 *
=======
            <pre class="prettyprint source linenums"><code>	/** @namespace */
	frm = {}; 
	
	/**
	 * Creates a local coordinate system with a given origin and the X-Axis and Y-Axis pointing towards the specfied points 
	 * @param {array / vertex object} origin - Origin of the local coordinate system
	 * @param {array / vertex object} xPoint - Point on the X-Axis 
	 * @param {array / vertex object} yPoint - Point on the Y-Axis
	 * @returns {frame object }  - A Frame Object
	 * @memberof frm
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */

<<<<<<< HEAD
	/**
	 * Prints to console
	 * @param {string} content - Message to be printed on the console
	 * @returns {null}
=======
		if( dot(xaxis, yaxis) != 0)
			print("Axes are not perpendicular");

		return new mObj_frame(origin, xaxis, yaxis, undefined);

	};
	        
	/**
	 * Creates a local coordinate system with a given origin and the X-Axis and Z-Axis pointing towards the specfied points 
	 * @param {array / vertex object} origin - Origin of the local coordinate system
	 * @param {array / vertex object} xPoint - Point on the X-Axis
	 * @param {array / vertex object} zPoint - Point on the Z-Axis
	 * @returns {frame object }  - A Frame Object
	 * @memberof frm
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	mod.print = function(content){
		// try to find vidamo web app, if found print in vidamo console

<<<<<<< HEAD
		this.content = content;
=======
		if( dot(xaxis, zaxis) != 0)
			print("Axes are not perpendicular");

		return new mObj_frame(origin, xaxis, undefined, zaxis);
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		try{
			var logString = "&lt;div style='color: green;'>" + this.content + '&lt;/div>';
			document.getElementById('log').innerHTML += logString;
		}catch(err){
			console.log('warnning: vidamo web app not connected.');
		}
	};

	/**
<<<<<<< HEAD
	 * Converts RGB values into Hex color code
	 * @param {int} red - Value between 0-255 for red color
	 * @param {int} green - Value between 0-255 for green color
	 * @param {int} blue - Value between 0-255 for blue color
	 * @returns {string} - HexValue
	 */
	mod.rgbToHex = function(red, green, blue){
		
		return '0x'+toHex(red)+toHex(green)+toHex(blue);
			
		function toHex(n) {
			 n = parseInt(n,10);
			 if (isNaN(n)) return "00";
			 n = Math.max(0,Math.min(n,255));
			 return "0123456789ABCDEF".charAt((n-n%16)/16)
				  + "0123456789ABCDEF".charAt(n%16);
		}
	};
=======
	 * Creates a local coordinate system with a given origin and the Y-Axis and Z-Axis pointing towards the specfied points 
	 * @param {array / vertex object} origin - Origin of the local coordinate system
	 * @param {array / vertex object} xPoint - Point on the Y-Axis
	 * @param {array / vertex object} zPoint - Point on the Z-Axis
	 * @returns {frame object }  - A Frame Object
	 * @memberof frm
	 */
	byYZPoints = function(origin, yPoint, zPoint){

		if(origin.getGeometry != undefined)
			origin = origin.getGeometry();

		var yaxis = [yPoint[0]-origin[0], yPoint[1]-origin[1], yPoint[2]-origin[2]];
		var zaxis = [zPoint[0]-origin[0], zPoint[1]-origin[1], zPoint[2]-origin[2]];		

		if( dot(zaxis, yaxis) != 0)
			print("Axes are not perpendicular");

		return new mObj_frame(origin, undefined, yaxis, zaxis)
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	
	/**
	 * Converts degrees into radians
	 * @param {float} degree - Degrees to be converted
	 * @returns {float} 
	 */
	convertDegreesToRadians = function( degrees ){
		return 0.01745*degrees;
	};

	/**
<<<<<<< HEAD
	 * Converts radians into degrees
	 * @param {float} radians - Radians to be converted
	 * @returns {float} 
	 */
	convertRadiansToDegrees = function( radians ){
		return 57.29*radians;
	};

	/**
	 * Returns absolute (positive) value of a number
	 * @param {float} number  
	 * @returns {float} Positive value
	 */
	getAbsoluteValue = function( number ){
		return Math.abs( number );
	};

	/**
	 * Returns value of a number upto significant digits
	 * @param {float} number  - Number
	 * @param {int} number  - Number of significant digits needed
	 * @returns {float} 
	 */
	getSignificantDigits = function( number, digits){
		return number.toFixed(digits);
	};

	/**
	 * Computes dot product of two matrices
	 * @param {array} mat1  - Matrix 1
	 * @param {array} mat2  - Matrix 2
	 * @returns {float} 
=======
	 * Creates a local coordinate system with a given origin and the X and Y axis Vectors. Units vectors are not neccessary. 
	 * @param {array / vertex object} origin - Origin of the local coordinate system
	 * @param {array} xAxis - X-Axis Vector in [x, y, z] format
	 * @param {array} yAxis - Y-Axis Vector in [x, y, z] format
	 * @returns {frame object }  - A Frame Object
	 * @memberof frm
	 */
	byXYAxes = function(origin, xAxis, yAxis){

		if(origin.getGeometry != undefined)
			origin = origin.getGeometry();

		if( dot(xAxis, yAxis) != 0)
			print("Axes are not perpendicular");

		return new mObj_frame(origin, xAxis, yAxis, undefined);

	};

	/**
	 * Creates a local coordinate system with a given origin and the X and Y axis Vectors. Units vectors are not neccessary. 
	 * @param {array / vertex object} origin - Origin of the local coordinate system
	 * @param {array} xAxis - X-Axis Vector in [x, y, z] format
	 * @param {array} zAxis - Z-Axis Vector in [x, y, z] format
	 * @returns {frame object }  - A Frame Object
	 * @memberof frm
	 */
	byXZAxes = function(origin, xAxis, zAxis){

		if(origin.getGeometry != undefined)
			origin = origin.getGeometry();

		if( dot(xAxis, zAxis) != 0)
			print("Axes are not perpendicular");

		return new mObj_frame(origin, xAxis, undefined, zAxis);

	};

	/**
	 * Creates a local coordinate system with a given origin and the Y and Z axis Vectors. Units vectors are not neccessary. 
	 * @param {array / vertex object} origin - Origin of the local coordinate system
	 * @param {array} yAxis - Y-Axis Vector in [x, y, z] format
	 * @param {array} zAxis - Z-Axis Vector in [x, y, z] format
	 * @returns {frame object }  - A Frame Object
	 * @memberof frm
	 */
	byYZAxes = function(origin, yAxis, zAxis){

		if(origin.getGeometry != undefined)
			origin = origin.getGeometry();

		if( dot(zAxis, yAxis) != 0)
			print("Axes are not perpendicular");

		return new mObj_frame(origin, undefined, yAxis, zAxis);

	};

	//
	//
	// solid functions
	//
	//
	/** @namespace */
	sld = {};

	/**
	 * Creates a solid object by extruding a surface along x, y, z vectors of the given local coordinate system
	 * @param { frame object } frame - Local coordinate system 
	 * @param { surface object } surface - Surface to be extruded
	 * @param { float } xDistance - Amount of extrusion in the direction of the x-Axis of the frame
	 * @param { float } yDistance - Amount of extrusion in the direction of the y-Axis of the frame
	 * @param { float } zDistance - Amount of extrusion in the direction of the z-Axis of the frame
	 * @returns { solid object }  - Solid object 
	 * @memberof sld
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	getDotProduct = function( mat1, mat2 ){
		return verb.core.Vec.dot(mat1, mat2);
	};

	/**
<<<<<<< HEAD
	 * Computes cross product of two matrices
	 * @param {array} mat1  - Matrix 1
	 * @param {array} mat2  - Matrix 2
	 * @returns {array} 
=======
	 * Creates a single solid object from a list of surfaces 
	 * @param { array } listOfSurfaces - Array of surfaces which form the solid object 
	 * @returns { solid object }  - Solid object 
	 * @memberof sld
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	getCrossProduct = function( mat1, mat2 ){
		return verb.core.Vec.cross(mat1, mat2);
	};
	

<<<<<<< HEAD
	/*
	 *
	 * List Operations
	 *
	 */

	/**
	 * Returns a number sequence in the form of an array
	 * @param {float or int} start  - Starting value of the sequence
	 * @param {float or int} end  - Ending value of the sequence
	 * @param {float or int} stepSize  - Increment or Decrement value to get to the 'end' value from the 'start' value
	 * @returns {array} 
	 */
	makeSequence = function(start, end, stepSize){
=======
	//
	//
	// surface functions
	//
	//
	/** @namespace */
	srf = {};

	/**
	 * Creates a Nurbs surface from user-specified data
	 * @param {int} degreeU - Degree of the surface in the u-Direction 
	 * @param {int} degreeV - Degree of the surface in the v-Direction 
	 * @param {array} knotsU - Knots in the u-Direction 
	 * @param {array} knotsV - Knots in the v-Direction 
	 * @param {array} controlPoints - Array of points / vertex objects through which the curve passes ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {array} weights - Weights ( optional parameter; maybe 'undefined' )
	 * @returns { surface object }  - Surface object
	 * @memberof srf
	 */
	nurbsByData = function ( degreeU, degreeV, knotsU, knotsV, controlPoints, weights ){
		
		var controlPoints = controlPoints.map( function(p){ 
								
								if(p.getGeometry != undefined) 
									return p.getGeometry(); 
								else 
									return p; } )

		var srf = new verb.geom.NurbsSurface.byKnotsControlPointsWeights( degreeU,degreeV,knotsU,knotsV,controlPoints, weights )

		//transform( frame.toLocal() );
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		var arr = [];
		for(var i = start; i &lt;= end; i = i + stepSize)
			arr.push(i);
		return arr;
	};

	/**
<<<<<<< HEAD
	 * Adds an element to a list
	 * @param {array} list  - List to which an element needs to be pushed
	 * @param {array element} object - Element to be pushed into the list
	 * @returns {null} 
=======
	 * Creates a Nurbs surface using the corner-points
	 * @param {array} cornerpoints - Array of points / vertex objects ( [ [x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4] ] )
	 * @returns { surface object }  - Surface object
	 * @memberof srf
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	addToList = function( list, object ){
		list.push( object );
	};

	/**
<<<<<<< HEAD
	 * Finds the index of the first occurence of an array element. 
	 * @param {array} list  - List in which an element needs to be searched
	 * @param {array element} object - Element to be searched for
	 * @returns {int} Returns -1 if the element doesn't exist in array. 
	 */
	indexOfObject = function( list, object ){
		return list.indexOf( object );
	};

	/**
	 * Removes an array element from a list by it's index number
	 * @param {array} list  - List in which an element needs to be removed
	 * @param {int} index - Index to be removed
	 * @returns {null} 
=======
	 * Creates a surface by extruding a curve along x, y, z vectors of the given local coordinate system
	 * @param { frame object } frame - Local coordinate system 
	 * @param { curve object } curve - Curve to be extruded
	 * @param { float } xDistance - Amount of extrusion in the direction of the x-Axis of the frame
	 * @param { float } yDistance - Amount of extrusion in the direction of the y-Axis of the frame
	 * @param { float } zDistance - Amount of extrusion in the direction of the z-Axis of the frame
	 * @returns { surface object }  - Surface object 
	 * @memberof sld
	 */
	nurbsByExtrusion  = function(curve, frame, xDistance, yDistance, zDistance){

		var profile = curve.getGeometry();
		var ex_profile = MOBIUS.shift( curve, frame, xDistance, yDistance, zDistance, true).getGeometry();

		var srf = new verb.geom.NurbsSurface.byLoftingCurves( [profile, ex_profile], 1 );
		//transform( frame.toLocal() );

		return new mObj_geom_Surface( srf ) ;

	};

	/**
	 * Creates a surface by lofting an array of curves 
	 * @param {array} listOfCurves - Array of curve objects
	 * @param {int} degree - Degree of the Surface ( optional parameter; defaults to 3)
	 * @returns { surface object }  - Surface Object 
	 * @memberof srf
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	removeIndexFromList = function( list, index ){
		list.splice(index, 1);
	};

	/**
<<<<<<< HEAD
	 * Gets the maximum value in a numeric array
	 * @param {array} valueList - List from which maximum value is required
	 * @returns {float / int} 
	 */
	getMaxValue = function( valueList ){
		var maxValue = valueList[0];
		for(var i=0; i&lt;valueList.length; i++)
			maxValue = Math.max(maxValue, valueList[i]);
		return maxValue;
	};

	/**
	 * Gets the minimum value in a numeric array
	 * @param {array} valueList - List from which minimum value is required
	 * @returns {float / int} 
=======
	 * Creates a surface by revolving a curve around the z-Axis of the specified local coordinate system 
	 * @param { frame object } frame - Local coordinate system; Z-Axis of the frame determines the axis of revolution
	 * @param { curve object } sectionCurve - Curve Object which has to be revolved about the z-Axis
	 * @param { float } angle - Angle of revolution in Degrees 
	 * @returns { surface object }  - Surface Object 
	 * @memberof srf
	 */
	nurbsByRevolution = function(frame, sectionCurve, angle){

		angle = 0.0174533*angle

		var profile = sectionCurve.getGeometry();

		profile = ( profile.transform( frame.toGlobal() ) ); 

		var srf = new mObj_geom_Surface( new verb.geom.RevolvedSurface( profile, [0,0,0], [0,0,1], angle ) ) ;

		setGeometry( getGeometry().transform( frame.toLocal() ) );

		return srf;
			
	};

	/**
	 * Creates a surface by sweeping the section-curve along the rail-curve
	 * @param { curve object } sectionCurve - Curve Object which determines the profile of the sweep
	 * @param { curve object } railCurve - Curve Object which determines the path of the sweep
	 * @returns { surface object }  - Surface Object 
	 * @memberof srf
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	getMinValue = function( valueList ){
		var minValue = valueList[0];
		for(var i=0; i&lt;valueList.length; i++)
			minValue = Math.min(minValue, valueList[i]);
		return minValue;
	};

	/**
<<<<<<< HEAD
	 * Gets the sum of a numeric array
	 * @param {array} valueList - List which is to be summed
	 * @returns {float / int} 
=======
	 * Creates a spherical surface at the origin of the frame given 
	 * @param { frame object } frame - Local Coordinate System; Orientation of the sphere is determined by the local axes of the frame
	 * @param { float } radius - Radius of the sphere
	 * @returns { surface object }  - Surface Object 
	 * @memberof srf
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	sumList = function( valueList ){
		var sum = 0;
		for(var i=0; i&lt;valueList.length; i++)
			sum += valueList[i];
		return sum;
	};

	/**
<<<<<<< HEAD
	 * Gets the avaerage of a numeric array
	 * @param {array} valueList - List which is to be averaged
	 * @returns {float / int} 
=======
	 * Creates a cylinderical or conical surface at the origin of the frame given 
	 * @param { frame object } frame  - Local Coordinate System; Orientation of the cone is determined by the local axes of the frame
	 * @param { float } height - Height of the cone
	 * @param { float } radius1 - Radius of the base of the cone 
	 * @param { float } radius2 - Radius of the top of the cone; Setting this value to 0 would result in a cone; Setting this to be equal to radius1 would result in a cylinder
	 * @returns {mobiusobject}  - NURBS Surface
	 * @memberof srf
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	averageList = function( valueList ){
		return VIDAMO.sumList( valueList )/ valueList.length;
	};

	/**
<<<<<<< HEAD
	 * Returns the span of the list - the difference between the maximum and the minimum value in the list
	 * @param {array} valueList - List which is to be analyzed
	 * @returns {float / int} 
=======
	 * Creates a circular pipe along a given path 
	 * @param { curve object } centreCurve  - Curve Object which determines the path of the pipe
	 * @param { float } radius - Radius of the pipe
	 * @returns {mobiusobject}  - NURBS Surface
	 * @memberof srf
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	rangeOfList = function( valueList ){
		return VIDAMO.getMaxValue( valueList ) - VIDAMO.getMinValue( valueList );
	};

	/**
<<<<<<< HEAD
	 * Returns the length of the list 
	 * @param {array} valueList - List which is to be analyzed
	 * @returns {int} 
=======
	 * Divides the surface into a grid, based number of divisions in the u and v directions and  
	 * returns the uv-Parameters for the corresponding grid points
	 * @param { surface object } surface  - Surface Object for which the uv-Parameters are required
	 * @param { int } uSegments  - Number of divisions required in the u-Direction
	 * @param { int } vSegments  - Number of divisions required in the v-Direction
	 * @returns {2D array}  - List of UV positions [ [ u1, v1 ], [ u2, v2 ], [ u3, v3 ] ...]; Length of list is equal to uSegments*vSegments
	 * @memberof srf	 
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	getListLength = function( valueList ){
		return valueList.length
	};


	/*
	 *
	 *	Geometry Analysis Functions
	 *
	 */

	/**
	 * Returns the centre of a NURBS Curve, NURBS Surface or a 3D Geometry
	 * @param {array} mObj - MobiusDataObject containing Nurbs Geometry or 3D Geometry
	 * @returns {array} Point - [x, y, z]
	 */
	getCentre = function(mObj){
		//calculate centre based on what kind of object
		var geometry = mObj.geometry;

		if(geometry instanceof verb.geom.NurbsCurve)
			return geometry.point(0.5);
		else if(geometry instanceof verb.geom.NurbsSurface)
			return geometry.point(0.5, 0.5);
		else if(geometry instanceof THREE.Geometry)
			return geometry.center();
		else
			return "Invalid Input"
	};

	/**
<<<<<<< HEAD
	 * Returns the distance between two points or position vectors
	 * @param {point / MobiusDataObject} point - [x, y , z] or MobiusDataObject with PositionVector
	 * @returns {float} Distance 
=======
	 * Returns the actual points on the surface, given a corresponding list of uv-parameters or a single [u, v] point
	 * @param { surface object } surface  - Surface Object for which the uv-Parameters are required
	 * @param { 2D array / array } uvList  - List of UV positions [ [ u1, v1 ], [ u2, v2 ], [ u3, v3 ] ...] or single [u, v]
	 * @returns {array}  - List of vertex objects
	 * @memberof srf
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	distanceBetweenTwoPoints = function( point1, point2){
		var deltaX, deltaY, deltaZ;

		if(point1.geometry instanceof THREE.Vector3 &amp;&amp; point2.geometry instanceof THREE.Vector3){
			pnt1 = point1.geometry;
			pnt2 = point2.geometry;
			deltaX = pnt1.x - pnt2.x;
			deltaY = pnt1.y - pnt2.y;
			deltaZ = pnt1.z - pnt2.z;
		}
		else if(point1.constructor === Array &amp;&amp; point2.constructor === Array){
			deltaX = point1[0] - point2[0];
			deltaY = point1[1] - point2[1];
			deltaZ = point1[2] - point2[2];
		}
		else
			return "Invalid Input"

		var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
		return distance;
	};

	/**
<<<<<<< HEAD
	 * Returns the length of a MobiusDataObject containing a PositionVector or a NURBS Curve
	 * @param {MobiusDataObject} mObj - PositionVector or NURBS Curve
	 * @returns {float} Length 
=======
	 * Creates a collection of frames, centred at the the points specified by the uv-List, with the x and y Axes of the frame aligned along
	 * the surface 
	 * @param { surface object } surface  - Surface Object along which frames are required
	 * @param { 2D array } uvList  - List of UV positions [ [ u1, v1 ], [ u2, v2 ], [ u3, v3 ] ...] or single [u, v]
	 * @returns {array}  - List of Frame Objects
	 * @memberof srf
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	getLength = function( mObj ){
		var geom = mObj.geometry;
		return geom.length();
	};

<<<<<<< HEAD
=======
		if(uvList.constructor.name != "Array")
			uvList = [uvList];

		for(var i=0; i&lt;uvList.length; i++){
			var origin = surface.getGeometry().point( uvList[i][0], uvList[i][1] );
			var xaxis = verb.core.Vec.sub( origin, surface.getGeometry().point( uvList[i][0] + 0.1, uvList[i][1] ) );
			var yaxis = verb.core.Vec.sub( origin, surface.getGeometry().point( uvList[i][0] , uvList[i][1] + 0.1 ) )
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

	/*
	 *
	 * Verbs Functions
	 * Input - according to requirements, Output - MobiusDataObject with NURBS Geometry
	 *
	 */

<<<<<<< HEAD
	/**
	 * Returns a MobiusDataObject containing a NURBS Curve
	 * @param {array} startPoint - Starting point of the line in [x,y,z] format
	 * @param {array} endPoint - Ending point of the line in [x,y,z] format	 
	 * @returns {MobiusDataObject}  - NURBS Curve
	 */
	makeLine = function(startPoint, endPoint){
		// input variations
		// start, end could be a vector3 - has to be converted into an array
=======
		if(frames.length == 1)
			frames = frames[0]

		return frames;
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		return new MobiusDataObject( new verb.geom.Line(startPoint, endPoint) );
	};

	/**
<<<<<<< HEAD
	 * Returns a MobiusDataObject containing a NURBS Curve
	 * @param {array} centerPoint - Centre point of the Arc in [x,y,z] format
	 * @param {array} xaxis - Direction of X-Axis of the Arc in [x,y,z] format 
	 * @param {array} yaxis - Direction of Y-Axis of the Arc in [x,y,z] format 
	 * @param {array} radius - Radius of the Arc
	 * @param {float} minAngle - Minimum Angle in Radians
	 * @param {float} maxAngle - Maximum Angle in Radians
	 * @returns {MobiusDataObject}  - NURBS Curve
	 */
	makeArc = function(centerPoint, xaxis, yaxis, radius, minAngle, maxAngle){
		// input variations
		// center, axis and yaxis could be vector3
		return new MobiusDataObject( new verb.geom.Arc(centerPoint,xaxis,yaxis,radius,minAngle,maxAngle) );
	};

	/**
	 * Returns a MobiusDataObject containing a NURBS Curve
	 * @param {array} points - Array of Control Points for the Bezier Curve ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {array} weights - Weights
	 * @returns {MobiusDataObject}  - NURBS Curve
	 */
	makeBezierCurve = function(points, weights){
		// points could be vector3
		return new MobiusDataObject( new verb.geom.BezierCurve(points, weights) );
	};

	/**
	 * Returns a MobiusDataObject containing a NURBS Curve
	 * @param {array} centerPoint - Centre point of the Circle in [x,y,z] format
	 * @param {array} xaxis - Direction of X-Axis of the Circle in [x,y,z] format 
	 * @param {array} yaxis - Direction of Y-Axis of the Circle in [x,y,z] format 
	 * @param {array} radius - Radius of the Arc
	 * @returns {MobiusDataObject}  - NURBS Curve
=======
	 * Returns a list of unit vectors normal to the surface the points on specified by the uv-List
	 * @param { surface object } surface  - Surface Object 
	 * @param { 2D array } uvList  - List of UV positions [ [ u1, v1 ], [ u2, v2 ], [ u3, v3 ] ...] or single [u, v]
	 * @returns {array}  - List of Normal Unit Vectors 
	 * @memberof srf
	 */
	getNormals = function( surface, uvList ){

		if(uvList.constructor.name != "Array")
			uvList = [uvList];

		var normals = [];
		for(var i=0; i&lt;uvList.length; i++)
			normals.push( verb.core.Vec.normalized( surface.normal(uvList[i][0], uvList[i][1])) );

		if(normals.length == 1)
			normals = normals[0]

		return normals;

	};

	/**
	 * Returns a list of unit vectors tangent to the surface at the points specified by the uv-List
	 * @param { surface object } surface  - Surface Object 
	 * @param { 2D array } uvList  - List of UV positions [ [ u1, v1 ], [ u2, v2 ], [ u3, v3 ] ...] or single [u, v]
	 * @returns {2D array}  - List of Tangent Unit Vectors along two directions  (or single tangent unit vector)
	 * @memberof srf
	 */
	getTangents = function( surface, uvList ){

		if(uvList.constructor.name != "Array")
			uvList = [uvList];

		var tangents = [];
		for(var i=0; i&lt;uvList.length; i++){
			var xaxis = verb.core.Vec.normalized( verb.core.Vec.sub( origin, surface.getGeometry().point( uvList[i][0] + 0.1, uvList[i][1] ) ));
			var yaxis = verb.core.Vec.normalized( verb.core.Vec.sub( origin, surface.getGeometry().point( uvList[i][0], uvList[i][1] + 0.1 ) ));
			tangents.push( [xaxis, yaxis])
		}

		if(tangents.length == 1)
			tangents = tangents[0]

		return tangents;
	}; 
 
 	/**
	 * Returns a list or a single iso-curve object along u or v-Direction 
	 * @param { surface object } surface  - Surface Object 
	 * @param { array } uOrvList  - List of positions at which iso-curves are required or single u/v value
	 * @param { array } useV  - Specifies if the given list of positions is in u-Direction or v-Direction; True value means v-Direction;
	 * @returns {2D array}  - List of Tangent Unit Vectors along two directions 
	 * @memberof srf
	 */
	getIsoCurves = function( surface, uOrvList, useV ){

		if(surface.getGeometry != undefined)
			surface = surface.getGeometry();

		if(uvList.constructor.name != "Array")
			uvList = [uvList];

		var isoCurves = [];
		for(var t=0; t&lt;uOrvList.length; t++){
			var crv = new mObj_geom_Curve( surface.isocurve( uOrvList[t], useV ) );
			isoCurves.push(crv);
		}

		if(isoCurves.length == 1)
			isoCurves = isoCurves[0]; 

		return isoCurves;
	};

	/**
	 * Subdivides a surface into a grid of smaller surfaces - a mesh solid
	 * @param {surface object} surface - Surface Object 
	 * @param {int} uvGrid - UV positions with u &amp; v dimensions [ [ u1, v1 ], ... [ un, vn ], uDimension, vDimension ]
	 * @returns {solid object} Solid object  
	 * @memberof srf
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	makeCircleBoundary = function(centerPoint,xaxis,yaxis,radius){
		return new MobiusDataObject( new verb.geom.Circle(centerPoint,xaxis,yaxis,radius) );
	};

<<<<<<< HEAD
	/**
	 * Returns a MobiusDataObject containing a NURBS Curve
	 * @param {array} centerPoint - Centre point of the Ellipse in [x,y,z] formats
	 * @param {array} xaxis - Direction of X-Axis of the Ellipse in [x,y,z] format; Length of this vector determines length of x-Axis of ellipse;
	 * @param {array} yaxis - Direction of Y-Axis of the Ellipse in [x,y,z] format; Length of this vector determines length of y-Axis of ellipse;
	 * @returns {MobiusDataObject}  - NURBS Curve
	 */
	makeEllipse = function ( centerPoint ,xaxis,yaxis ){
		return new MobiusDataObject( new verb.geom.Ellipse( centerPoint,xaxis,yaxis ) );
=======
/*	carve = function(surface, uv1, uv2, hole){

	};*/


	//
	//
	// Curves
	//
	//
	/** @namespace */
	crv = {};

	/**
	 * Creates a Nurbs curve from user-specified data
	 * @param {frame object} - Local Coordinate System 
	 * @param {int} degree - Degree of the curve
	 * @param {array} knots - Knots of the curve
	 * @param {array} controlPoints - Array of points / vertex objects through which the curve passes ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {array} weights - Weights ( optional parameter; maybe 'undefined' )
	 * @returns { curve object }  - Curve object
	 * @memberof crv
	 */
	nurbsByData = function( frame, degree, knots, controlPoints, weights ){

		controlPoints = controlPoints.map( function(p){ 
								
								if(p.getGeometry != undefined) 
									return p.getGeometry(); 
								else 
									return p; } )

		var crv = new verb.geom.NurbsCurve.byKnotsControlPointsWeights( degree, knots, controlPoints, weights )
		crv = transform( frame.toLocal() );

		return new mObj_geom_Curve( crv ) ;

>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	};

	/**
	 * Returns a MobiusDataObject containing a NURBS Curve
	 * @param {array} centerPoint - Centre point of the EllipseArc in [x,y,z] formats
	 * @param {array} xaxis - Direction of X-Axis of the EllipseArc in [x,y,z] format; Length of this vector determines length of x-Axis of ellipse;
	 * @param {array} yaxis - Direction of Y-Axis of the EllipseArc in [x,y,z] format; Length of this vector determines length of y-Axis of ellipse;
	 * @param {float} minAngle - Minimum Angle in Radians
	 * @param {float} maxAngle - Maximum Angle in Radians
	 * @returns {MobiusDataObject}  - NURBS Curve
	 */
	makeEllipseArc = function ( centerPoint,xaxis,yaxis,minAngle,maxAngle ){
		return new MobiusDataObject( new verb.geom.EllipseArc( centerPoint,xaxis,yaxis,minAngle,maxAngle ) );
	};

	/**
<<<<<<< HEAD
	 * Returns a MobiusDataObject containing a NURBS Curve
	 * @param {array} points - Array of points through which the curve passes ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {int} degree - Degree of the Curve
	 * @returns {MobiusDataObject}  - NURBS Curve
	 */
	makeCurveByPoints = function( points, degree ){
		return new MobiusDataObject( new verb.geom.NurbsCurve.byPoints( points, degree ) );
	};

	/**
	 * Returns a MobiusDataObject containing a NURBS Curve
	 * @param {int} degree - Degree of the Curve
	 * @param {array} knots - Knots
	 * @param {array} controlPoints - Array of points through which the curve passes ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {array} weights - Weights
	 * @returns {MobiusDataObject}  - NURBS Curve
	 */
	makeCurveByKnotsControlPointsWeights = function ( degree,knots,controlPoints,weights ){
		return new MobiusDataObject( new verb.geom.NurbsCurve.byKnotsControlPointsWeights( degree,knots,controlPoints,weights ) );
=======
	 * Creates a Nurbs curve passsing through a list of points 
	 * @param {frame object} - Local Coordinate System 
	 * @param {array} points - Array of points / vertices through which the curve passes ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {int} degree - Degree of the Curve
	 * @returns {curve object}  - NURBS Curve
	 * @memberof crv
	 */
	nurbsByPoints = function( frame, points, degree ){

		points = points.map( function(p){ 
								
								if(p.getGeometry != undefined) 
									return p.getGeometry(); 
								else 
									return p; } )

		var crv = new verb.geom.NurbsCurve.byPoints( points, degree )
		crv = transform( frame.toLocal() );

		return new mObj_geom_Curve( crv ) ;
	};

	/**
	 * Creates a Bezier Nurbs curve passsing through a list of points 
	 * @param {frame object} - Local Coordinate System 
	 * @param {array} points - Array of points / vertices through which the curve passes ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {int} degree - Degree of the Curve
	 * @returns {curve object}  - NURBS Curve
	 * @memberof crv
	 */
	bezierByPoints = function(frame, points, weights) {

		points = points.map( function(p){ 
								
								if(p.getGeometry != undefined) 
									return p.getGeometry(); 
								else 
									return p; } );

		var crv =  new verb.geom.BezierCurve( points, weights ) ;
		crv = transform( frame.toLocal() );

		return new mObj_geom_Curve( crv );
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	};

	/**
<<<<<<< HEAD
	 * Returns a MobiusDataObject containing a NURBS Surface
	 * @param {int} degreeU - DegreeU of the Surface
	 * @param {int} degreeV - DegreeV of the Surface
	 * @param {array} knotsU - Knots in U Direction
	 * @param {array} knotsV - Knots in V Direction
	 * @param {array} controlPoints - Array of points through which the curve passes ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {array} weights - Weights
	 * @returns {MobiusDataObject}  - NURBS Surface
	 */
	makeSurfaceByKnotsControlPointsWeights = function ( degreeU,degreeV,knotsU,knotsV,controlPoints,weights ){
		return new MobiusDataObject( new verb.geom.NurbsSurface.byKnotsControlPointsWeights( degreeU,degreeV,knotsU,knotsV,controlPoints,weights ) );
=======
	 * Creates an arc centred at the origin of the frame; The arc is created in the xy-plane of the local coordinate system
	 * @param {frame object} frame - Local coordinate system
	 * @param {float} radius - Radius of the arc
	 * @param {float} minAngle - Starting angle in degrees
	 * @param {float} maxAngle - Ending angle in degrees
	 * @returns {curve object}  - NURBS Curve
	 * @memberof crv
	 */
	arc = function(frame, radius, minAngle, maxAngle){

		minAngle = 0.0174533*minAngle;
		maxAngle = 0.0174533*maxAngle;

		var arc = new verb.geom.Arc( [0,0,0], [1,0,0], [0,1,0], radius, minAngle, maxAngle) 
		arc = arc.transform( frame.toLocal() );
		
		return new mObj_geom_Curve( arc ) ;

>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	};

	/**
	 * Returns a MobiusDataObject containing a NURBS Surface
	 * @param {array} point - Corner points in [x,y,z] format
	 * @returns {MobiusDataObject}  - NURBS Surface
	 */
	makeSurfaceByCorners = function ( point0, point1, point2, point3 ){
		return new MobiusDataObject( new verb.geom.NurbsSurface.byCorners ( point0,point1,point2,point3 ) );
	};

	/**
<<<<<<< HEAD
	 * Returns a MobiusDataObject containing a NURBS Surface
	 * @param {MobiusDataObject} mObj - MobiusDataObject with NURBS Curve Geometry
	 * @param {array} centerPoint - CentrePoint in [x,y,z] format
	 * @param {array} axis - Axis of revolution in [x,y,z] format	 
	 * @param {float} angle - Angle of revolution in radians
	 * @returns {MobiusDataObject}  - NURBS Surface
=======
	 * Creates an circle centred at the origin of the frame; The circle is created in the xy-plane of the local coordinate system
	 * @param {frame object} frame - Local coordinate system
	 * @param {float} radius - Radius of the arc
	 * @returns {curve object}  - NURBS Curve
	 * @memberof crv
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	makeSurfaceByRevolution = function ( mObj, centerPoint, axis, angle ){
		var profile = mObj.geometry;
		return new MobiusDataObject( new verb.geom.RevolvedSurface( profile, centerPoint, axis, angle )  );
	};

	/**
<<<<<<< HEAD
	 * Returns a MobiusDataObject containing a NURBS Surface
	 * @param {MobiusDataObject} mObj - MobiusDataObject with NURBS Curve Geometry
	 * @param {MobiusDataObject} mObj - MobiusDataObject with NURBS Curve Geometry
	 * @returns {MobiusDataObject}  - NURBS Surface
=======
	 * Creates an ellipse centred at the origin of the frame; The ellipse is created in the xy-plane of the local coordinate system
	 * @param {frame object} frame - Local coordinate system
	 * @param {float} xRadius - Radius of the ellipse
	 * @param {float} yRadius - Radius of the ellipse
	 * @returns {curve object}  - NURBS Curve
	 * @memberof crv
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	makeSurfaceBySweep = function ( mObjProfile, mObjRail){
		var profile = mObjProfile.geometry;
		var rail = mObjRail.geometry;
		return new MobiusDataObject( new verb.geom.SweptSurface ( profile, rail ) );
	};

	/**
<<<<<<< HEAD
	 * Returns a MobiusDataObject containing a NURBS Surface
	 * @param {array} listOfCurves - Array of MobiusDataObject with NURBS Curve Geometry
	 * @param {int} degree - Degree of the Surface
	 * @returns {MobiusDataObject}  - NURBS Surface
	 */
	makeSurfaceByLoft = function(listOfCurves, degree){
		var deg = degree || 3;
		var curves = [];
		for(var c=0; c&lt;listOfCurves.length; c++)
			curves.push(listOfCurves[c].geometry); demoC = curves;
		return new MobiusDataObject( new verb.geom.NurbsSurface.byLoftingCurves( curves, deg ) );
=======
	 * Creates an ellipse arc centred at the origin of the frame; The ellipse arc is created in the xy-plane of the local coordinate system
	 * @param {frame object} frame - Local coordinate system
	 * @param {float} xRadius - Radius of the ellipse arc
	 * @param {float} yRadius - Radius of the ellipse arc
	 * @param {float} minAngle - Starting angle in degrees
	 * @param {float} maxAngle - Ending angle in degrees
	 * @returns {curve object}  - NURBS Curve
	 * @memberof crv
	 */
	ellipseArc = function(frame, xRadius, yRadius, minAngle, maxAngle){

		minAngle = 0.0174533*minAngle;
		maxAngle = 0.0174533*maxAngle;

		var ellipseArc = new verb.geom.EllipseArc( [0,0,0], [1,0,0], [0,1,0], radius, minAngle, maxAngle );
		ellipseArc = ellipse.transform( frame.toLocal() );

		return new mObj_geom_Curve( ellipseArc ); 
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	};

	/**
<<<<<<< HEAD
	 * Returns a MobiusDataObject containing a NURBS Surface
	 * @param {MobiusDataObject} mObjProfile - Array of MobiusDataObject with NURBS Curve Geometry
	 * @param {array} direction - Direction of Sweep in [x,y,z] format	 
	 * @returns {MobiusDataObject}  - NURBS Surface
	 */
	makeSurfaceByExtrusion = function ( mObjProfile, direction){
		var profile = mObjProfile.geometry;
		return new MobiusDataObject( new verb.geom.ExtrudedSurface( profile, direction ) );
	};

	/**
	 * Returns a MobiusDataObject containing a NURBS Surface
	 * @param {array} centrePoint - CentrePoint in [x,y,z] format	
	 * @param {float} radius - Radius of the Sphere 	 
	 * @returns {MobiusDataObject}  - NURBS Surface
=======
	 * Creates a line
	 * @param {frame object} frame - Local coordinate system
	 * @param {point / vertex} startPoint - Starting point
	 * @param {point / vertex} endPoint - Ending point
	 * @returns {curve object}  - NURBS Line Curve
	 * @memberof crv
	 */
	line = function(frame, startPoint, endPoint){

		if( startPoint.getGeometry != undefined )
			startPoint = startPoint.getGeometry();
		if( endPoint.getGeometry != undefined )
			endPoint = endPoint.getGeometry();

		var crv = new verb.geom.Line(startPoint, endPoint);
		crv = transform( frame.toLocal() );
	
		return new mObj_geom_Curve( crv );

	};

	/**
	 * Divides a curve into multiple segments and gives the corresponding t-parameter on the curve
	 * @param {curve object} curve - Curve Object to be divided
	 * @param {int} numPoints - Number of divisions required
	 * @returns {array}  - List of t-parameters at the division points
	 * @memberof crv
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	makeSurfaceAsSphere = function(centrePoint, radius){
		return new MobiusDataObject( new verb.geom.SphericalSurface(centrePoint, radius) );
	};

	/**
<<<<<<< HEAD
	 * Returns a MobiusDataObject containing a NURBS Surface
	 * @param {array} axis - Axis Direction of the cone in [x,y,z] format
	 * @param {array} xaxis - Direction of x-axis of cone in [x,y,z] format
	 * @param {float} base - Radius of cone base
	 * @param {float} height - Height of the cone
	 * @param {float} radius - Radius of cone
	 * @returns {MobiusDataObject}  - NURBS Surface
=======
	 * Divides a curve into multiple segments and equal distances along the curve and returns the corresponding t-parameter on the curve
	 * @param {curve object} curve - Curve Object to be divided
	 * @param {float} distance - Distance of each segment - along the curve
	 * @returns {array}  - List of t-parameters at the division points
	 * @memberof crv
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	makeSurfaceAsCone = function( axis,xaxis,base,height,radius ){
		return new MobiusDataObject( new verb.geom.ConicalSurface( axis,xaxis,base,height,radius ) );
	};

	/**
<<<<<<< HEAD
	 * Returns a MobiusDataObject containing a NURBS Surface
	 * @param {array} axis - Axis Direction of the cylinder in [x,y,z] format
	 * @param {array} xaxis - Direction of x-axis of cylinder in [x,y,z] format
	 * @param {float} base - Radius of cylinder base
	 * @param {float} height - Height of the cylinder
	 * @param {float} radius - Radius of cylinder
	 * @returns {MobiusDataObject}  - NURBS Surface
=======
	 * Returns a list of points on the curve, corresponding the list of t-parameters specified
	 * @param {curve object} curve - Curve Object 
	 * @param {array} tList - Array of t-parameters 
	 * @returns {array}  - List of vertex objects on the curve 
	 * @memberof crv
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	makeSurfaceAsCylinder = function ( axis, xaxis, base, height, radius ){
		return new MobiusDataObject( new verb.geom.CylindricalSurface( axis,xaxis,base,height,radius ) );
	};

	/**
	 * Returns a point on the surface at the given parameter values
	 * @param {MobiusDataObject} surface - MobiusDataObject with NURBS Surface
	 * @param {int} u - Parameter in u-direction
	 * @param {int} v - Parameter in v-direction
	 * @returns {array} point [x,y,z]
	 */
	getPointOnSurface = function( surface, u, v ){
		var srf = surface.geometry;
		if(srf instanceof verb.geom.NurbsSurface)
			return srf.point( u, v );
		else
			return "Invalid Input"
	};

	/**
<<<<<<< HEAD
	 * Returns a point on the curve at the given parameter value
	 * @param {MobiusDataObject} curve - MobiusDataObject with NURBS Curve
	 * @param {int} t - Parameter in u-direction
	 * @returns {array} point [x,y,z]
=======
	 * Returns a list of frames, centred at t-points on the curve, with the x-Axis along the tangent to the curve at that
	 * point and z-Axis along the upVector
	 * @param {curve object} curve - Curve Object 
	 * @param {array} tList - Array of t-parameter
	 * @param {array} upVector - Vector specifying the z-axis of the frames  
	 * @returns {array}  - List of frames
	 * @memberof crv
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	getPointOnCurve = function( curve, t ){
		var crv = curve.geometry;
		if( crv instanceof verb.geom.NurbsCurve)
			return crv.point( t );
		else
			return "Invalid Input"
	};

<<<<<<< HEAD
	/**
	 * Returns an array of 't' values which divide the curve equally
	 * @param {MobiusDataObject} curve - MobiusDataObject with NURBS Curve
	 * @param {int} divisons - Number of divisions in which the curve should be divided
	 * @returns {array} curve parameters [t1, t2, t3 ...]
	 */
	divideCurveByEqualArcLength = function( curve, divisions ){
		var crv = curve.geometry;
		var points = crv.divideByEqualArcLength( divisions )
			.map(function(u){ return ( u.u ); } );
=======
		if(tList.constructor.name != "Array")
			tList = [tList];


		var frames = tList.map( function(t){
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		return points;
	};

<<<<<<< HEAD
	/**
	 * Returns an array of 't' values which divide the curve by length
	 * @param {MobiusDataObject} curve - MobiusDataObject with NURBS Curve
	 * @param {float} arcLength - Length 
	 * @returns {array} curve parameters [t1, t2, t3 ...]
	 */
	divideCurveByArcLength = function( curve, arcLength ){
		var crv = curve.geometry;
		var points = crv.divideByArcLength( arcLength )
			.map(function(u){ return ( u.u ); } );
=======
		if(frames.length == 1)
			frames = frames[0]

		return frames;
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		return points; //convert these into vector points
	};
<<<<<<< HEAD
=======

	/**
	 * Returns a list of unit tangent vectors at points corresponding to a list of or a single t-value on a curve
	 * @param {curve object} curve - Curve Object 
	 * @param {array} tList - Array of t-parameter or single t-parameter
	 * @returns {array}  - List or single unit tangent vector 
	 * @memberof crv
	 */
	getTangents = function(curve, tList){
	
		var curve = curve.getGeometry();		
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

	/**
	 * Returns a tangent on the curve at the given parameter value
	 * @param {MobiusDataObject} curve - MobiusDataObject with NURBS Curve
	 * @param {int} t - Parameter in u-direction
	 * @returns {array} tangent [x,y,z]
	 */
	getTangentAtCurveParameter = function( curve, t ){
		var crv = curve.geometry;
		if( crv instanceof verb.geom.NurbsCurve)
			return crv.tangent(t);
		else
			return 'Invalid Input';
	};

	/**
	 * Returns a tangent on the surface at the given parameter values
	 * @param {MobiusDataObject} surface - MobiusDataObject with NURBS Surface
	 * @param {int} u - Parameter in u-direction
	 * @param {int} v - Parameter in v-direction
	 * @returns {array} tangent [x,y,z]
	 */
	getNormalAtSurfaceParameter = function( surface, u, v ){
		var srf = surface.geometry;
		if(srf instanceof verb.geom.NurbsSurface)
			return srf.normal( u, v);
		else
			return 'Invalid Input';
	};


	/**
<<<<<<< HEAD
	 * Subdivides a surface into smaller surfaces
	 * @param {MobiusDataObject} surface - MobiusDataObject with NURBS Surface
	 * @param {int} ugrid - Divisions in u-direction
	 * @param {int} vgrid - Divisions in v-direction
	 * @returns {array} Array of MobiusDataObjects with NURBS Surfaces
	 */
	makeMeshBySubdivision = function( mObj, ugrid, vgrid ){
=======
	 * Returns a list of curve objects obtained by dividing a single curve at points corresponding to a list of t-values
	 * @param {curve object} curve - Curve Object 
	 * @param {array} tList - Array of t-parameter
	 * @returns {array}  - List of curve objects
	 * @memberof crv
	 */
	divideByTList = function(curve, tList){
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		var surface = mObj.geometry;

		if(surface instanceof verb.geom.NurbsSurface){
			var div_surfaces = [], gridPoints = [];
			var uincr = 1/ugrid;
			var vincr = 1/vgrid;

			//for uv lines
			for(var i=0; i &lt;= ugrid; i++){
				for(var seg=0; seg &lt;= vgrid; seg++)
					gridPoints.push(surface.point(i*uincr, seg*vincr));
			}

			// creation of polygons from the gridPoints
			for(var i=0; i&lt; gridPoints.length-vgrid-2; i++){
				if((i+vgrid+2)%(vgrid+1) != 0 || i==0){
					// construction of the verbs four point surface
					var mbObj = new MobiusDataObject( new verb.geom.NurbsSurface.byCorners(gridPoints[i], gridPoints[i+1],  gridPoints[i+vgrid+2], gridPoints[i+vgrid+1]) )
					div_surfaces.push(mbObj)
				}
			}

			return div_surfaces
		}
		else
			return "Invalid Input"
	};

	/**
	 * Creates a tube of a given radius, from a given line
	 * @param {MobiusDataObject} line - MobiusDataObject with NURBS Line
	 * @param {float} radius - Radius of the tube
	 * @returns {MobiusDataObject} MobiusDataObject with NURBS Surface
	 */
	makeTubeByLine = function( mObj, radius ){

		var line = mObj.geometry;

<<<<<<< HEAD
		var start = line.start();
		var end = line.end();
=======
	/**
	 * Converts a curve into a polyline passing through points corresponding to t-paramters on the curve
	 * @param {curve object} curve - Curve Object 
	 * @param {array} tList - Array of t-parameter
	 * @returns {curve object}  - Curve Object
	 * @memberof crv
	 */
	convertToPolyline = function(curve, tList){
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		var axis = [start[0] - end[0], start[1] - end[1], start[2] - end[2]]
			, height = 1 //this is a multiplying factor to the axis vector
			, radius = radius;

		//construction of a perpendicular vector
		var xaxis = [1, 1, 1];
		if(axis[0] * axis[1] * axis[2] != 0)
			xaxis = [ -axis[1]/axis[0], 1, 0]
		else if(axis.reduce(function(n, val) {
				return n + (val === 0);
			}, 0) > 1)
			xaxis = [0, 0, 0]
		else{
			//is there a better way??
			var flag = 0
			xaxis[axis.indexOf(0)] = 0
			for(var i=0; i &lt; 3; i++){
				if(xaxis[i] == 0)
					continue;
				else if(!flag)
					flag = axis[i]
				else
					xaxis[i] = -(flag/axis[i])
			}
		}

		var tube = new verb.geom.CylindricalSurface( axis, xaxis, end, height, radius );

<<<<<<< HEAD
		return new MobiusDataObject( tube );
	};

	/**
	 * Gives the corner points of a surface
	 * @param {MobiusDataObject} surface - MobiusDataObject with NURBS Surface
	 * @returns {array} Array of Points [ [corner1], [corner2], [corner3], [corner4] ], where corner is of form - [x, y, z]
	 */
	getCornerPointsFromSurface = function( mObj ){
=======
	/**
	 * Returns the length of the curve
	 * @param {curve object} curve - Curve Object 
	 * @returns {float}  - Length of the curve
	 * @memberof crv
	 */
	length = function( curve ){
		return curve.getGeometry().length();
	};

	//
	//
	// Points
	//
	//
	/** @namespace */
	pnt = {};

	/**
	 * Creates a vertex object with the given point geometry
	 * @param {frame object} frame - Local Coordinate System
	 * @param {float} x - x-position
	 * @param {float} y - y-position
	 * @param {float} z - z-position
	 * @return {vertex object} Vertex object
	 * @memberof pnt
	 */
	byCoords = function(x, y, z){
		return new mObj_geom_Vertex([x, y, z]);
	}

	/**
	 * Returns the mid-point between two points
	 * @param {point / vertex object} point1 - [x, y , z] or Vertex
	 * @param {point / vertex object} point2 - [x, y , z] or Vertex
	 * @returns {point} Mid Point of line between the two given points 
	 * @memberof pnt
	 */
	midPoint = function(point1, point2){

		if( point1.getGeometry != undefined )
			point1 = point1.getGeometry();
		if( point2.getGeometry != undefined )
			point2 = point2.getGeometry();
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		var polygon = mObj.geometry;

		return [
			polygon.point(0,0),
			polygon.point(1,0),
			polygon.point(1,1),
			polygon.point(0,1)]
	};

	/**
<<<<<<< HEAD
	 * Makes a point from the coordinates
	 * @param {float} x - X Coordinate of the point
	 * @param {float} y - Y Coordinate of the point
	 * @param {float} z - Z Coordinate of the point
	 * @returns {array} Point of form - [x, y, z]
	 */
	makePoint = function(x, y, z){
=======
	 * Returns the distance between two points or vertices
	 * @param {point / vertex object} point1 - [x, y , z] or Vertex
	 * @param {point / vertex object} point2 - [x, y , z] or Vertex
	 * @returns {float} Distance 
	 * @memberof pnt
	 */
	distance = function(point1, point2){

		if( point1.getGeometry != undefined )
			point1 = point1.getGeometry();
		if( point2.getGeometry != undefined )
			point2 = point2.getGeometry();
				 
		var deltaX, deltaY, deltaZ;

		deltaX = point1[0] - point2[0];
		deltaY = point1[1] - point2[1];
		deltaZ = point1[2] - point2[2];

		var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
		return distance;
	};

	//
	//
	//	Vector functions
	//
	//
	/** @namespace */
	vec= {};

	/**
	 * Returns a vector with magnitude x, y, z along the x, y, z axes
	 * @param {float} x - Magnitude along x-direction
	 * @param {float} y - Magnitude along y-direction
	 * @param {float} z - Magnitude along z-direction
	 * @returns {array} Vector 
	 * @memberof vec
	 */
	byCoords = function(x, y, z){
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
		return [x, y, z];
	};

	/*
	 *
	 * Three.js Geometry Functions
	 * Input - according to requirements, Output - MobiusDataObject with Three.js or ThreeBSP geometry
	 *
	 */

	/**
<<<<<<< HEAD
	 * Creates a vector for a point
	 * @param {float} x - X Coordinate of the point OR {array} [x,y,z] - Point form
	 * @param {float} y - Y Coordinate of the point
	 * @param {float} z - Z Coordinate of the point
	 * @returns {MobiusDataObject} Containing vector from origin to point
	 */
	makePositionVector = function(x, y, z){
		if(x.constructor === Array &amp;&amp; y == undefined &amp;&amp; z == undefined)
			return new MobiusDataObject( new THREE.Vector3( x[0], x[1], x[2] ));
		else
			return new MobiusDataObject( new THREE.Vector3(x, y, z));
	};

	/**
	 * Returns an array of position vectors from an array of points
	 * @param {array} list_of_points - Array of points of form - [ [ point1 ], [ point2 ], [ point3 ] ... ] where points are of form [x, y, z]
	 * @returns {array} Array of MobiusDataObjects containing position vectors
	 */
	makePositionVectorsFromPoints = function( list_of_points ){
		var mObjArr = [];
		for(var i=0; i&lt;list_of_points.length; i++){
			var obj = new MobiusDataObject( new THREE.Vector3(list_of_points[i][0], list_of_points[i][1], list_of_points[i][2]));
			mObjArr.push(obj);
		}
		return mObjArr;
	};

	/**
	 * Creates a circle of a given radius and resolution
	 * @param {float} radius - Radius of the circle
	 * @param {int} segments - Number of segments 
	 * @returns {MobiusDataObject} MobiusDataObject containing CircleGeometry
	 */
	makeCircle = function(radius, segments){
		return new MobiusDataObject( new THREE.CircleGeometry( radius, segments ));
	};

	/**
	 * Creates a cylinder
	 * @param {float} radiusTop - Radius of the top of the cylinder
	 * @param {float} radiusBottom - Radius of the bottom of the cylinder
	 * @param {float} height - Height of the cylinder
	 * @param {float} radiusSegments - Segments in the radius of the cylinder
	 * @param {float} heightSegments - Segments in the height of the cylinder
	 * @param {boolean} openEnded - True or False value - if the cylinder is open at the ends
	 * @returns {MobiusDataObject} MobiusDataObject with CylinderGeometry
	 */
	makeCylinder = function(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded ){
		return new MobiusDataObject( new THREE.CylinderGeometry( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded ));
	};

	/**
	 * Creates a polyline from an array of points
	 * @param {array} arrOfPoints - Array of points of the form - [[x,y,z], [x,y,z], [x,y,z], [x,y,z] ...]
	 * @returns {MobiusDataObject} MobiusDataObject with Polyline (Vertice Geometry)
	 */
	makePolyline = function(arrOfPoints){
		var pline = new THREE.Geometry();
=======
	 * Computes angle between two vectors
	 * @param {array} vector1  - Vector 1 in [x, y, z] format
	 * @param {array} vector2  - Vector 2 in [x, y, z] format
	 * @returns {float} radians
	 * @memberof vec
	 */
	angle = function(vector1, vector2){
		var dotP = MOBIUS.dot( vector1,  vector2 );
		var cos_t = dotP / (MOBIUS.length( vector1 ) * MOBIUS.length( vector2 ) );
		return Math.cosh(cos_t);
	};	

	/**
	 * Computes the summation of two vectors
	 * @param {array} vector1  - Vector 1 in [x, y, z] format
	 * @param {array} vector2  - Vector 2 in [x, y, z] format
	 * @returns {array} vector
	 * @memberof vec
	 */
	add = function( vector1, vector2){
		return verb.core.Vec.add( vector1, vector2 );
	};

	/**
	 * Computes the subtraction of two vectors
	 * @param {array} vector1  - Vector 1 in [x, y, z] format
	 * @param {array} vector2  - Vector 2 in [x, y, z] format
	 * @returns {array} vector
	 * @memberof vec
	 */
	subtract = function( vector1, vector2 ){
		return verb.core.Vec.sub( vector1, vector2 )
	};

	/**
	 * Computes length of the vector
	 * @param {array} vector  - Vector in [x, y, z] format
	 * @returns {float} length
	 * @memberof vec
	 */
	length = function(vector){
		return Math.sqrt( vector[0]*vector[0] + vector[1]*vector[1] + vector[2]*vector[2] );
	};

	/**
	 * Resets the length of the given vector
	 * @param {array} vector  - Vector in [x, y, z] format 
	 * @param {float} length - New length of the vector
	 * @returns {array} Vector 
	 * @memberof vec
	 */
	resize = function(vector, length){
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		for(var point=0; point &lt; arrOfPoints.length; point++)
			pline.vertices.push(new THREE.Vector3(arrOfPoints[point][0], arrOfPoints[point][1], arrOfPoints[point][2]));

		return new MobiusDataObject( pline );
	};


	/**
<<<<<<< HEAD
	 * Creates a box from the length, breadth and height
	 * @param {float} length - Length of the box
	 * @param {float} breadth - Breadth of the box
	 * @param {float} height - Height of the box
	 * @returns {MobiusDataObject} MobiusDataObject with BoxGeometry
	 */
	makeBox = function(length, breadth, height){
		return new MobiusDataObject ( new THREE.BoxGeometry( length, breadth, height ) ) ;
	};
=======
	 * Scales the given vector
	 * @param {array} vector  - Vector in [x, y, z] format 
	 * @param {float} factor - Scaling factor of the vector
	 * @returns {array} Vector 
	 * @memberof vec
	 */
	scale = function(vector, factor){

		return [ factor*vector[0], factor*vector[1], factor*vector[2] ] ;
	}
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

	/**
	 * Creates a Sphere of a given radius
	 * @param {radius} length - Length of the box
	 * @returns {MobiusDataObject} MobiusDataObject with SphereGeometry
	 */
	makeSphere = function(radius){
		return new MobiusDataObject ( new THREE.SphereGeometry( radius , 32, 32) ) ;
	};

	/**
<<<<<<< HEAD
	 * Creates a polygon from 2D points - points have to be specified in anticlockwise direction
	 * @param {array} pointsXY - Array of 2D Points of form - [ [x,y], [x,y], [x,y], [x,y] ...]
	 * @returns {MobiusDataObject} MobiusDataObject with ShapeGeometry
	 */
	makePolygonByPoints = function( pointsXY ){
=======
	 * Computes unit vector
	 * @param {array} vector  - Vector in [x, y, z] format
	 * @returns {array} Unit Vector
	 * @memberof vec
	 */
	normalize = function(vector){
		return verb.core.Vec.normalized( vector );
	}
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		// shape creation
		var customShape = new THREE.Shape();
		customShape.moveTo(pointsXY[0], pointsXY[1]);
		for(var pointNo=1; pointNo &lt; pointsXY.length; pointNo++)
			customShape.lineTo(pointsXY[pointNo][0], pointsXY[pointNo][1]);
		customShape.lineTo(pointsXY[0][0], pointsXY[0][1]);

<<<<<<< HEAD
		return new MobiusDataObject ( customShape );
	};

	/**
	 * Creates an extrusion from a polygon
	 * @param {MobiusDataObject} mObj - MobiusDataObject containing ShapeGeometry
	 * @param {float} thickness - Amount of extrusion
	 * @param {boolean} bevel - True or False for bevel or not
	 * @param {array} pathPoints -  Array of points of form [[x, y, z], [x, y, z] [x, y, z], ...] which specifies the path along which the polygon has to be extruded
	 * @returns {MobiusDataObject} MobiusDataObject with ExtrudeGeometry
=======
	//
	//
	//	Objects
	//
	//
	/** @namespace */
	obj = {};

	/**
	 * Creates a copy of the object with the same geometry, transformations, material and data at the same location
	 * @param {any object} mObj - Object to be cloned
	 * @returns {object} Cloned object
	 * @memberof obj
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	extrudePolygon = function(mObj, thickness, bevel, pathPoints ){

		//mObj has to have shape  :/
		var shape = mObj.geometry;
		
		pathPoints = pathPoints || [];


		if( shape instanceof THREE.Shape ){
			var extrudeSettings = { amount: thickness, 
									bevelEnabled: bevel, 
									bevelSegments: 2, 
									steps: 2, 
									bevelSize: 1, 
									bevelThickness: 1 };
			
			// path method - object has to be centred about origin for the extrusion to work correctly - rotation is going to be arbitary
			if(pathPoints.length){
				var path;
				if(pathPoints.length == 2){
					// it's a line
					path = new THREE.LineCurve3(new THREE.Vector3( pathPoints[0][0], pathPoints[0][1], pathPoints[0][2]), 
												new THREE.Vector3( pathPoints[1][0], pathPoints[1][1], pathPoints[1][2]));
				} else{
					//path is a curve
					path = new THREE.Curve(); 
				}
				
				extrudeSettings.extrudePath = path;
			}
				
			var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
			
			// shear method - inaccurate results
			// if(direction != undefined){ console.log("inside direction", direction);
				 //applying shear matrix according to extrude in direction specified
				 // var matrix = new THREE.Matrix4();
				 // var Syx = direction.x / direction.y,
				 // Syz = direction.z / direction.y;
				 // matrix.set(   1,   Syx,   0,   0,
				 // 0,     1,   0,   0,
				 // 0,   Syz,   1,   0,
				 // 0,     0,   0,   1  );
				 // geometry.applyMatrix( matrix ); 
			// }

			return new MobiusDataObject( geometry );
		}
		else
			return "Invalid Input. Please input polygon"

	};

	/**
<<<<<<< HEAD
	 * Creates a Lathe from an array of points
	 * @param {array} points - Array of Points of form - [ [x,y,z], [x,y,z], [x,y,z], [x,y,z] ...]
	 * @param {int} segments - Number of segments in the Lathe
	 * @returns {MobiusDataObject} MobiusDataObject with LatheGeometry
=======
	 * Adds material to an object
	 * @param {object} obj - Object to which material is to be added
	 * @param {String} material_type - "MeshBasicMaterial", "MeshNormalMaterial", "MeshLambertMaterial", "LineBasicMaterial" etc... 
	 * @param {boolean} wireframe - 'True' if wireframe is required. 
	 * @param {hexCode} color - Hex Code of the color
	 * @param {boolean} transparent - 'True' if transparency is required. 
	 * @returns null
	 * @memberof obj
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	makeLathe = function( points, segments ){
		var pts = [];
		for(var i=0; i&lt;points.length; i++)
			pts.push(new THREE.Vector3(points[i][0], points[i][1], points[i][2]))
		return new MobiusDataObject( new THREE.LatheGeometry( pts, segments ) );
	};

	/**
<<<<<<< HEAD
	 * Creates a plane from the width and height
	 * @param {float} width - Width of the plane
	 * @param {float} height - Height of the plane
	 * @returns {MobiusDataObject} MobiusDataObject with PlaneGeometry
=======
	 * Adds data to an object
	 * @param {object} obj - Object to which data is to be added
	 * @param {String} dataName - Name of the property
	 * @param {String / int / object ... } dataValue - Value of the property
	 * @returns null
	 * @memberof obj
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	makePlane = function( width, height ){
		return new MobiusDataObject( new THREE.PlaneGeometry( width, height, 1) );
	};

	/**
	 * Creates a polyhedron geometry 
	 * @param {array} 
	 * @param {array} 
	 * @returns {MobiusDataObject} MobiusDataObject with PolyhedronGeometry
	 */
	makePolyhedron = function( verticesOfCube, indicesOfFaces ){
		return new MobiusDataObject( new THREE.PolyhedronGeometry( verticesOfCube, indicesOfFaces, 6, 2 ) );
	};

	/**
<<<<<<< HEAD
	 * Creates a 2D Ring Shape
	 * @param {float} innerRadius - Radius of the hollow portion of the ring
	 * @param {float} outerRadius - External radius of the ring
	 * @param {int} segments - Determines resolution
	 * @returns {MobiusDataObject} MobiusDataObject with 2D Ring Geometry
=======
	 * Returns the centre of a NURBS Curve, NURBS Surface or Solid Geometry
	 * @param {object} object - Mobius object
	 * @returns {array} Point - [x, y, z]
	 * @memberof obj
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	make2DRing = function( innerRadius, outerRadius, segments ){
		return new MobiusDataObject( new THREE.RingGeometry( innerRadius, outerRadius, segments ) );
	};

	/**
	 * Creates a Tetrahedron
	 * @param {float} radius - Radius of the tetrahedron
	 * @returns {MobiusDataObject} MobiusDataObject with TetrahedronGeometry
	 */
	makeTetrahedron = function( radius ){
		return new MobiusDataObject( new THREE.TetrahedronGeometry( radius ) );
	};

	/**
	 * Creates a Torus Geometry
	 * @param {float} radius - Radius of the hollow portion of the ring
	 * @param {float} tube - 
	 * @param {int} radialSegments - Determines resolution in radial direction
	 * @param {int} tubularSegments - Determines resolution in tubular direction
	 * @returns {MobiusDataObject} MobiusDataObject with TorusGeometry
	 */
	makeTorus = function(radius, tube, radialSegments, tubularSegments){
		return new MobiusDataObject( new THREE.TorusGeometry( radius, tube, radialSegments, tubularSegments ) );
	};

	/**
	 * Creates a Torus Knot Geometry
	 * @param {float} radius - Radius of the hollow portion of the ring
	 * @param {float} tube - 
	 * @param {int} radialSegments - Determines resolution in radial direction
	 * @param {int} tubularSegments - Determines resolution in tubular direction
	 * @returns {MobiusDataObject} MobiusDataObject with TorusKnotGeometry
	 */
	makeTorusKnot = function( radius, tube, radialSegments, tubularSegments ){
		return new MobiusDataObject( new THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments) );
	};

	/**
	 * Extracts the point from a position vector
	 * @param {MobiusDataObject} positionVector - Converts position vector object back to point form
	 * @returns {array} Point of form [x, y, z]
	 */
	getPointFromPositionVector = function( positionVector ){
		var pos = positionVector.geometry;
		return [ pos.x, pos.y, pos.z ];
	};

<<<<<<< HEAD
	/*
	 *
	 *	Transformation Functions
	 *
	 */

	/**
	 * Creates a unique copy of the object with the same geometry, transformations, material and data
	 * @param {MobiusDataObject} mObj - Object to be cloned
	 * @param {float} xCoord - x-coordinate of the point where the clone appears
	 * @param {float} yCoord - y-coordinate of the point where the clone appears
	 * @param {float} zCoord - z-coordinate of the point where the clone appears
	 * @returns {MobiusDataObject} Cloned object
=======
	//
	//
	//	Transformation functions
	//
	//
	/** @namespace */
	trn = {};

	/**
	 * Reflects the object about the XY plane of the frame
	 * @param {object} object - Object to be reflected
	 * @param {frame object} frame - Local coordinate system
	 * @param {boolean} copy - Determines if the object is to be copied before transformation
	 * @returns {object} - Transformed Object or Copy 
	 * @memberof trn
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	makeCopy = function(mObj, xCoord, yCoord, zCoord){

		// for output cloning
		if( mObj.geometry == undefined ){
			console.log("Non-Mobius passed to copy function");
			return mObj;
		}
		
		var new_mObj = new MobiusDataObject( mObj.geometry );
		
		// attach data
		if(mObj.data != undefined)
			VIDAMO.addData(new_mObj, mObj.data);

		// if verbs object, has to be copied and translated
		if(mObj.geometry instanceof verb.geom.NurbsCurve || mObj.geometry instanceof verb.geom.NurbsSurface){
			
			var new_mObj = new MobiusDataObject( mObj.geometry );
			VIDAMO.moveObjectToPoint(new_mObj, xCoord, yCoord, zCoord);
			
		}else{
				// only required if it's a three.js object - to get the transformations on it
				var new_mObjMesh = new_mObj.extractGeometry( mObj.extractGeometry().clone() ); // sets the extractGeometry according to the original object
				new_mObjMesh.position.x = xCoord;
				new_mObjMesh.position.y = yCoord;
				new_mObjMesh.position.z = zCoord;
				new_mObjMesh.is_mObj = true; // because the mesh is not regenerated - and clone doesn't clone own properties - fix this later
		}
		
		return new_mObj; //needs to be sorted out
	};

	/**
<<<<<<< HEAD
	 * Shifts the object relative to its current position
	 * @param {MobiusDataObject} mObj - Object to be moved
	 * @param {float} shiftX - Distance to be moved in x-direction
	 * @param {float} shiftY - Distance to be moved in y-direction
	 * @param {float} shiftZ - Distance to be moved in z-direction
	 * @returns Null
	 */
	shiftObject = function(mObj, shiftX, shiftY, shiftZ){

		// could be a face too

		// if extractGeometry is called again, the translations would  be lost ..
		// original geometry interactions will not follow the translations - csg is ok, because that derieves from three.js itself

		if(mObj.geometry instanceof verb.geom.NurbsCurve || mObj.geometry instanceof verb.geom.NurbsSurface){
			var geometry = mObj.geometry; 
			var mat = [ [1,0,0, shiftX],
							[0,1,0,shiftY],
								[0,0,1, shiftZ],
									[0,0,0,1]
						];
			var transformedGeometry = geometry.transform( mat );
			mObj.geometry = transformedGeometry; 
			mObj.geometryUpdated = true;
		}else{
				var mesh = mObj.extractGeometry();
			mesh.translateX(shiftX);
			mesh.translateY(shiftY);
			mesh.translateZ(shiftZ);
=======
	 * Rotates the object about the axes of the frame. 
	 * @param {object} object - Object to be rotated
	 * @param {frame object} frame - Local coordinate system
	 * @param {float} angleX - Angle to be rotated about x-Axis of the frame, in degrees
	 * @param {float} angleY - Angle to be rotated about y-Axis of the frame, in degrees
	 * @param {float} angleZ - Angle to be rotated about z-Axis of the frame, in degrees
	 * @param {boolean} copy - Determines if the object is to be copied before transformation
	 * @returns {object} - Transformed Object or Copy 
	 * @memberof trn
	 */
	rotate = function(object, frame, angleX, angleY, angleZ, copy){

		if (object instanceof mObj_geom_Solid)
			object = object.getGeometry();

		if (object instanceof Array){

			var newobject = [];
			
			for(var obj=0; obj &lt; object.length; obj++)
				newobject.push(MOBIUS.rotate( object[obj], frame, angleX, angleY, angleZ, copy ));	
			
			return newobject;
		}

		if( copy )
			object = MOBIUS.copy( object );

		var geom = object.getGeometry();

		function getRotationMatrix( axis, angle){
				angle = 0.0174533*angle;
		        var cost = Math.cos(angle);
		        var sint = Math.sin(angle);
		        var ux = axis[0];
		        var uy = axis[1];
		        var uz = axis[2];

		        return [ [ cost + ux*ux*(1-cost), ux*uy*(1-cost) - uz*sint, ux*uz*(1-cost) + uy*sint, 0 ],
		                    [ ux*uy*(1-cost) + uz*sint,  cost + uy*uy*(1-cost),  uy*uz*(1-cost) - ux*sint, 0 ],
		                        [ ux*uz*(1-cost) - uy*sint, uy*uz*(1-cost) + ux*sint, cost + uz*uz*(1-cost), 0 ],
		                            [ 0, 0, 0, 1 ]
		                ];
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
		}
		
		//return mObj;
	};

	/**
	 * Moves the object to a target point
	 * @param {MobiusDataObject} mObj - Object to be moved
	 * @param {float} xCoord - x-coordinate of the target point where the clone appears
	 * @param {float} yCoord - y-coordinate of the target point where the clone appears
	 * @param {float} zCoord - z-coordinate of the target point where the clone appears
	 * @returns Null
	 */
	moveObjectToPoint = function(mObj, xCoord, yCoord, zCoord){


		// if extractGeometry is called again, the translations would  be lost ..
		// original geometry interactions will not follow the translations - csg is ok, because that derieves from three.js itself
		
		if(mObj.geometry instanceof verb.geom.NurbsCurve || mObj.geometry instanceof verb.geom.NurbsSurface){
			
			var orCenter = VIDAMO.getCentre(mObj);
			
			// translation required
			var target = [xCoord, yCoord, zCoord];
			var tx = target[0] - orCenter[0];
			var ty = target[1] - orCenter[1];
			var tz = target[2] - orCenter[2]; console.log(tx, ty, tz);
			
			VIDAMO.shiftObject( mObj, tx, ty, tz );		
		} else
			mObj.extractGeometry().position.set(xCoord, yCoord, zCoord);	

		//return mObj;
	};

	/**
	 * Scales the object along different axes
<<<<<<< HEAD
	 * @param {MobiusDataObject} mObj - Object to be scaled
	 * @param {float} scaleX - Scaling-factor along the x-direction; Should be set to '1' if no scaling is required.
	 * @param {float} scaleY - Scaling-factor along the y-direction; Should be set to '1' if no scaling is required.
	 * @param {float} scaleZ - Scaling-factor along the z-direction; Should be set to '1' if no scaling is required.
	 * @returns Null
=======
	 * @param {object} object - Object to be scaled
	 * @param {frame object} frame - Local coordinate system
	 * @param {float} scaleX - Scaling factor along x-Axis of the frame
	 * @param {float} scaleY - Scaling factor along y-Axis of the frame
	 * @param {float} scaleZ - Scaling factor along z-Axis of the frame
	 * @param {boolean} copy - Determines if the object is to be copied before transformation
	 * @returns {object} - Transformed Object or Copy 
	 * @memberof trn
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	scaleObject = function(mObj, scaleX, scaleY, scaleZ){
			
		// if extractGeometry is called again, the translations would  be lost ..
		// original geometry interactions will not follow the translations - csg is ok, because that derieves from three.js itself
		if(mObj.geometry instanceof verb.geom.NurbsCurve || mObj.geometry instanceof verb.geom.NurbsSurface){
			var geom = mObj.geometry;
			var centre = VIDAMO.getCentre(mObj);
			
			var mat = [ [scaleX, 0, 0, 0],
							[0,scaleY,0,0],
								[0,0,scaleZ,0],
									[0,0,0,1]
						];
			
			mObj.geometry = geom.transform(mat);
			
			// shift to original centre point
			VIDAMO.moveObjectToPoint(mObj, centre[0], centre[1], centre[2]);
			
			mObj.geometryUpdated = true;
		}else
			mObj.extractGeometry().scale.set(scaleX, scaleY, scaleZ);

		//return mObj;
	};

	/**
<<<<<<< HEAD
	 * Rotates the object about different axes
	 * @param {MobiusDataObject} mObj - Object to be rotated
	 * @param {float} xAxis - Angle (in Radians) about x-axis
	 * @param {float} yAxis - Angle (in Radians) about y-axis
	 * @param {float} zAxis - Angle (in Radians) about z-axis
	 * @returns Null
=======
	 * Shifts the object relative to its current position
	 * @param {object} object - Object to be shifted
	 * @param {frame object} frame - Local coordinate system
	 * @param {float} shiftX - Distance to be moved along x-Axis of the frame
	 * @param {float} shiftY - Distance to be moved along y-Axis of the frame
	 * @param {float} shiftZ - Distance to be moved along z-Axis of the frame
	 * @param {boolean} copy - Determines if the object is to be copied before transformation
	 * @returns {object} - Transformed Object or Copy 
	 * @memberof trn
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	rotateObject = function(mObj, xAxis, yAxis, zAxis){

		if(mObj.geometry instanceof verb.geom.NurbsCurve || mObj.geometry instanceof verb.geom.NurbsSurface){
			var geom = mObj.geometry;
			var centre = VIDAMO.getCentre(mObj);
			
			var mat_x = [ [1, 0, 0, 0],
							[0,	Math.cos(xAxis), -Math.sin(xAxis),0],
								[0,	Math.sin(xAxis), Math.cos(xAxis),0],
									[0,0,0,1]
						];
						
			var mat_y = [ [Math.cos(yAxis), 0, Math.sin(yAxis), 0],
							[0,1,0,0],
								[-Math.sin(yAxis), 0, Math.cos(yAxis),0],
									[0,0,0,1]
						];
						
			var mat_z = [ [Math.cos(zAxis), -Math.sin(zAxis), 0, 0],
							[Math.sin(zAxis),	Math.cos(zAxis),0,	0],
								[0,	0,	1,	0],
									[0,	0,	0,	1]
						];
			
			geom = geom.transform(mat_x);
			geom = geom.transform(mat_y);
			geom = geom.transform(mat_z);
			mObj.geometry = geom;
			
			// shift to original centre point
			VIDAMO.moveObjectToPoint(mObj, centre[0], centre[1], centre[2]);
			
			mObj.geometryUpdated = true;
		}else{
				// angles taken in radians
				var mesh = mObj.extractGeometry();
				mesh.rotateX(xAxis);
				mesh.rotateY(yAxis);
				mesh.rotateZ(zAxis);
		}
	};

	/**
	 * Creates a local coordinate system
	 * @returns {MobiusDataObject} Frame
	 */
	makeFrame = function(){
		return new MobiusDataObject( new THREE.Object3D() );
	};

	/**
	 * Adds an object to the local coordinate system (frame)
	 * @param {MobiusDataObject} frame - Frame
	 * @param {MobiusDataObject} object - Object to be added to frame
	 * @returns Null
	 */
	addToFrame = function( frame, object ){
		var frameRef = frame.geometry

		if(frameRef instanceof THREE.Object3D){

			frameRef.add(object.extractGeometry());
		}
		else
			console.log("Invalid Frame")
	};

	/**
<<<<<<< HEAD
	 * Points the z-axis of the object towards the point specified. 
	 * @param {MobiusDataObject} object - MobiusDataObject which needs to be re-oriented. Doesn't work with MobiusDataObjects containing NURBS geometry, currently. 
	 * @param {array} lookAtPoint - Target Point in form [x, y, z]
	 * @returns Null
=======
	 * Moves the centre of the object to a target point
	 * @param {object} object - Object to be shifted
	 * @param {point / vertex } point - Point to which the object is to be moved
	 * @param {boolean} copy - Determines if the object is to be copied before transformation
	 * @returns {object} - Transformed Object or Copy 
	 * @memberof trn
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	orientObjectTowards = function( object, lookAtPoint ){

		var lookAtPt;

<<<<<<< HEAD
		if(lookAtPoint.constructor === Array)
			lookAtPt = new THREE.Vector3( lookAtPoint[0], lookAtPoint[1], lookAtPoint[2] );
		else if(lookAtPoint instanceof THREE.Vector3)
			lookAt = lookAtPt;
=======
		if( point.getGeometry != undefined )
			point = point.getGeometry()

		// translation required
		var tx = point[0] - orCenter[0];
		var ty = point[1] - orCenter[1];
		var tz = point[2] - orCenter[2]; 
		
		return MOBIUS.shift( object, frame, tx, ty, tz, copy );		
	};
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		object.extractGeometry().lookAt( lookAtPt );

<<<<<<< HEAD
		return object;
	};


	/*
	 *
	 * CSG Functions
	 * Input - MobiusDataObjects, Output - MobiusDataObject
	 *
	 */

	/**
	 * Performs union operation on MobiusDataObjects with non-NURBS Geometry
	 * @param {MobiusDataObject} mObj1 - MobiusDataObject with Non-NURBS Geometry
	 * @param {MobiusDataObject} mObj2 - MobiusDataObject with Non-NURBS Geometry
	 * @returns {MobiusDataObject} MobiusDataObject containing ThreeBSP Geometry
	 */
	objectUnion = function( mObj1, mObj2 ){

		if(mObj1.geometry instanceof verb.geom.NurbsSurface || mObj2.geometry instanceof verb.geom.NurbsSurface)
			return "CSG functions currently only work with Three.js objects"
=======
	//
	//
	// Matrix operations
	//
	//
	/** @namespace */
	mtx = {};

	/**
	 * Computes dot product of two matrices
	 * @param {array} matrix1  - Matrix 1
	 * @param {array} matrix2  - Matrix 2
	 * @returns {float} 
	 * @memberof mtx
	 */
	dot = function( matrix1, matrix2 ){
		return verb.core.Vec.dot(matrix1, matrix2);
	};

	/**
	 * Computes cross product of two matrices
	 * @param {array} matrix1  - Matrix 1
	 * @param {array} matrix2  - Matrix 2
	 * @returns {array} 
	 * @memberof mtx
	 */
	cross = function( matrix1, matrix2 ){
		return verb.core.Vec.cross(matrix1, matrix2);
	};

	//
	//
	// Lists
	//
	//
	/** @namespace */
	lst = {};
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		var a = new ThreeBSP( mObj1.extractGeometry() );
		var b = new ThreeBSP( mObj2.extractGeometry() );

<<<<<<< HEAD
		var result;

		if(a.constructor !== Array){
			result = a.union( b );
		}

		return new MobiusDataObject( result );
	};

	/**
	 * Performs subtract operation on MobiusDataObjects with non-NURBS Geometry
	 * @param {MobiusDataObject} mObj1 - MobiusDataObject with Non-NURBS Geometry from which subtraction is to be done
	 * @param {MobiusDataObject} mObj2 - MobiusDataObject with Non-NURBS Geometry which is to be subtracted
	 * @returns {MobiusDataObject} MobiusDataObject containing ThreeBSP Geometry
=======
	/**
	 * Returns the length of the list 
	 * @param {array} list - List which is to be analyzed
	 * @returns {int} 
	 * @memberof lst
	 */
	length = function(list){
		return list.length
	};

	/**
	 * Finds the index of the first occurence of an array element. 
	 * @param {array} list  - List in which an element needs to be searched
	 * @param {array element} object - Element to be searched for
	 * @returns {int} Returns -1 if the element doesn't exist in array; else returns the index of the item
	 * @memberof lst
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	objectSubtract = function( mObj1, mObj2 ){

<<<<<<< HEAD
		if(mObj1.geometry instanceof verb.geom.NurbsSurface || mObj2.geometry instanceof verb.geom.NurbsSurface)
			return "CSG functions currently only work with Three.js objects"
=======
	/**
	 * Appends the item as it is to a list
	 * @param {array} list  - List in which item is to be added
	 * @param {array / element} itemOrList - List or single element to be added to the list
	 * @returns {NULL} 
	 * @memberof lst
	 */
	append = function(list, itemOrList){
		list.push(itemOrList);
	};
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		var a = new ThreeBSP( mObj1.extractGeometry() );
		var b = new ThreeBSP( mObj2.extractGeometry() );

<<<<<<< HEAD
		var result;
=======
	/**
	 * Inserts an item at a given index in a list
	 * @param {array} list  - List in which an element needs to be inserted
	 * @param {object} item - Element to be inserted
	 * @returns {NULL}
	 * @memberof lst
	 */
	insert = function(list, item, index){
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		if(a.constructor !== Array){
			result = a.subtract( b );
		}
<<<<<<< HEAD
=======
			
	};


	insert.prototype.return = false;

	/**
	 * Adds the elements of one list to another list
	 * @param {array} list  - List in which an elements need to be added
	 * @param {array} extension_list - List of elements to be added
	 * @returns {NULL}
	 * @memberof lst
	 */
	extend = function(list, extension_list){
		
		extension_list.map( function(t){
			list.push(t);
		});
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		return new MobiusDataObject( result );
	};

	/**
<<<<<<< HEAD
	 * Performs intersection operation on MobiusDataObjects with non-NURBS Geometry
	 * @param {MobiusDataObject} mObj1 - MobiusDataObject with Non-NURBS Geometry
	 * @param {MobiusDataObject} mObj2 - MobiusDataObject with Non-NURBS Geometry
	 * @returns {MobiusDataObject} MobiusDataObject containing ThreeBSP Geometry
=======
	 * Removes an array element from a list by its index number
	 * @param {array} list  - List in which an element needs to be removed
	 * @param {int} index - Index to be removed
	 * @returns {null} 
	 * @memberof lst
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	objectIntersect = function( mObj1, mObj2 ){

		if(mObj1.geometry instanceof verb.geom.NurbsSurface || mObj2.geometry instanceof verb.geom.NurbsSurface)
			return "CSG functions currently only work with Three.js objects"

		var a = new ThreeBSP( mObj1.extractGeometry() );
		var b = new ThreeBSP( mObj2.extractGeometry() );

<<<<<<< HEAD
		var result;
=======
	/**
	 * Returns a number sequence in the form of an array
	 * @param {float or int} start  - Starting value of the sequence
	 * @param {float or int} end  - Ending value of the sequence (not included in the sequence)
	 * @param {float or int} stepSize  - Increment or Decrement value to get to the 'end' value from the 'start' value
	 * @returns {array} 
	 * @memberof lst
	 */
	sequence = function(start, end, stepSize){
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		if(a.constructor !== Array){
			result = a.intersect( b );
		}

		return new MobiusDataObject( result );
	};


<<<<<<< HEAD
	/*
	 *	Data Functions
	 *	Input: MobiusDataObject or Topology Object; Output: Modified Object
	 *
=======
	/**
	 * Gets the average of a numeric array
	 * @param {array} numericList - List which is to be averaged
	 * @returns {float / int} Average of the numbers in the list
	 * @memberof lst
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */

	/**
<<<<<<< HEAD
	 * Adds material to an object
	 * @param {MobiusDataObject} obj - Object to which material is to be added
	 * @param {String} material_type - "MeshBasicMaterial", "MeshNormalMaterial", "MeshLambertMaterial", "LineBasicMaterial" etc... 
	 * @param {boolean} wireframe - 'True' if wireframe is required. 
	 * @param {hexCode} color - Hex Code of the color
	 * @param {boolean} transparent - 'True' if transparency is required. 
	 * @returns null
=======
	 * Gets the minimum value in a numeric list
	 * @param {array} numericList - List from which minimum value is required
	 * @returns {float / int} Minimum value
	 * @memberof lst
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	addMaterial = function(obj, material_type, wireframe, color, transparent){
		var option = {	wireframe: wireframe,
			color: color,
			transparent: transparent,
			side: THREE.DoubleSide
		};
		var material = new THREE[material_type](option);
		if(obj.constructor === Array){
			for(var i=0; i&lt;obj.length; i++)
				obj[i].material = material;
		}else
			obj.material = material;

		return obj;
	};

	/**
<<<<<<< HEAD
	 * Adds data to an object
	 * @param {MobiusDataObject} obj - Object to which data is to be added
	 * @param {String} dataName - Name of the property
	 * @param {String / int / object ... } dataValue - Value of the property
	 * @returns null
=======
	 * Gets the maximum value in a numeric array
	 * @param {array} numericList - List from which maximum value is required
	 * @returns {float / int} Maximum value
	 * @memberof lst
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
	 */
	addData = function(obj, dataName, dataValue){

		// decide on topology heirarchy also - if edge gets a property, do the vertices also get the same property?
		if(obj.constructor === Array){
			for(var i=0; i&lt;obj.length; i++){
				if(obj[i].data == undefined)
					obj[i].data = {};
				obj[i].data[dataName] = dataValue;
			}
		}else{
			if(obj.data == undefined)
				obj.data = {};
			obj.data[dataName] = dataValue;
		}
	};


<<<<<<< HEAD
	//Could be shifted to MobiusSide

	dataConversion = function(data){
=======
	/**
	 * Gets the sum of a numeric array
	 * @param {array} numericList - List which is to be summed
	 * @returns {float / int} Sum of the numbers in the list
	 * @memberof lst
	 */
	sum = function( numericList ){
		
		var sum = 0;
		
		for(var i=0; i&lt;numericList.length; i++)
			sum += numericList[i];
		
		return sum;
	
	};

	/**
	 * Returns the span of the list - the difference between the maximum and the minimum value in the list
	 * @param {array} numericList - List which is to be analyzed
	 * @returns {float / int} Span
	 * @memberof lst
	 */
	range = function( numericList ){
		
		return MOBIUS.max( numericList ) - MOBIUS.min( numericList );
	
	};
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

		for(var i = 0; i &lt; data.length; i++) {
			for (var m in data[i].value) {

<<<<<<< HEAD
				if (data[i].value[m] !== undefined) {

					if (data[i].value[m].constructor !== Array) {
						extract(data[i].value[m],
							data[i].geom,
							data[i].geomData);
					}
					else {
						var tempGeom = [];
						var tempData = [];

						for (var n = 0; n &lt; data[i].value[m].length; n++) {

							extract(data[i].value[m][n],
								tempGeom,
								tempData);
						}
						data[i].geom.push(tempGeom);
						data[i].geomData.push(tempData);
					}
					console.log(data[i].geom);

				}
			}
		}

		function extract (obj,geom,geomData){
			if(obj.constructor === Array){
				var tempGeom0 = [];
				var tempData0 = [];
=======
	//
	//
	// Misc functions
	//
	//
	/** @namespace */
	msc = {};

	/**
	 * Converts degrees into radians
	 * @param {float} degree - Degrees to be converted
	 * @returns {float} Value in Radians
	 * @memberof msc
	 */
	degToRad = function(degree){
		return 0.0174533*degree;
	};

	/**
	 * Converts radians into degrees
	 * @param {float} radians - Radians to be converted
	 * @returns {float} Value in Degrees
	 * @memberof msc
	 */
	radToDeg = function(radians){
		return 57.29*radians;
	};	

	/**
	 * Returns the sine value of an angle
	 * @param {float} angle - Angle in degrees
	 * @returns {float} Sine value
	 * @memberof msc
	 */
	sin = function( angle ){
		return Math.sin( 0.0174533*angle )
	}

	/**
	 * Returns the cos value of an angle
	 * @param {float} angle - Angle in degrees
	 * @returns {float} Sine value
	 * @memberof msc
	 */
	cos = function( angle ){
		return Math.cos( 0.0174533*angle )
	}

	/**
	 * Converts RGB values into Hex color code
	 * @param {int} red - Value between 0-255 for red color
	 * @param {int} green - Value between 0-255 for green color
	 * @param {int} blue - Value between 0-255 for blue color
	 * @returns {string} - HexValue
	 * @memberof msc
	 */
/*	rgbToHex = function(red, green, blue){
		
		return '0x'+toHex(red)+toHex(green)+toHex(blue);
			
		function toHex(n) {
			 n = parseInt(n,10);
			 if (isNaN(n)) return "00";
			 n = Math.max(0,Math.min(n,255));
			 return "0123456789ABCDEF".charAt((n-n%16)/16)
				  + "0123456789ABCDEF".charAt(n%16);
		}
	};*/
	
	/**
	 * Returns value of a number upto significant digits
	 * @param {float} number  - Number
	 * @param {int} digits  - Number of significant digits needed
	 * @returns {float} 
	 * @memberof msc
	 */
	sigDig = function(number, digits){
		return number.toFixed(digits);
	};

	/**
	 * Prints to console
	 * @param {string} content - Message to be printed on the console
	 * @returns {null}
	 * @memberof msc
	 */
	print = function(content){
		// try to find MOBIUS web app, if found print in MOBIUS console
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf

				for(var k = 0; k &lt; obj.length ; k++){
					extract(obj[k],tempGeom0,tempData0);
				}

				geom.push(tempGeom0);
				geomData.push(tempData0);
			}
			else if(obj instanceof  MobiusDataObject){
				geom.push( obj.extractGeometry() );
				geomData.push( obj.extractData() );
			}else{
				for(var key in obj){
					extract(obj[key],geom,geomData);
				}
			}
		}

		return data;
	};

<<<<<<< HEAD


/*
 *
 * Bridging Functions for all libraries used in Module - for geometry and topology
 *
 */

//
//	Functions forming bridge between data structure, topology and modules
//	Dependent on the modules being used for geometry and topology
//

//
//	Requirements
//	Function names should remain the same
//

//
//	Default Material Definitions
//
var default_material_meshFromThree = new THREE.MeshLambertMaterial( {
	side: THREE.DoubleSide,
	wireframe: false,
	shading: THREE.SmoothShading,
	transparent: false,
	color: 0x003399
} );
var default_material_meshFromVerbs = new THREE.MeshLambertMaterial( {
	side: THREE.DoubleSide,
	wireframe: false,
	shading: THREE.SmoothShading,
	transparent: false,
	color: 0x003399
} );
var default_material_lineFromVerbs = new THREE.LineBasicMaterial({
	side: THREE.DoubleSide,
	linewidth: 100,
	color: 0x003399
});
var default_material_lineFromThree = new THREE.LineBasicMaterial({
	side: THREE.DoubleSide,
	linewidth: 100,
	color: 0x003399
});
var default_material_pointFromThree = new THREE.PointCloudMaterial( { size: 5, sizeAttenuation: false } );
//
//	Function to convert native geometry into three.js Mesh geometry
//  Add another if-else condition for each new geometry
//
var convertGeomToThreeMesh = function( geom ){

	// internal function
	convertToThree = function(singleDataObject){

		if( singleDataObject instanceof THREE.Mesh  || singleDataObject instanceof THREE.Object3D ){
			return singleDataObject;
		}
		else if(singleDataObject instanceof THREE.Geometry || singleDataObject instanceof THREE.Curve){
			// if faces > 0 - it's a mesh
			if(singleDataObject.faces.length)
				return new THREE.Mesh( singleDataObject, default_material_meshFromThree || singleDataObject.material );
			else
				return new THREE.Line( singleDataObject, default_material_lineFromThree || singleDataObject.material ) // else line
		}
		else if(singleDataObject instanceof THREE.Vector3){
			var dotGeometry = new THREE.Geometry();
			dotGeometry.vertices.push(singleDataObject);
			return new THREE.PointCloud( dotGeometry, default_material_pointFromThree || singleDataObject.material );
		}
		else if(singleDataObject instanceof THREE.Shape){
			var geometry = new THREE.ShapeGeometry( singleDataObject );
			var mesh = new THREE.Mesh( geometry, default_material_meshFromThree || singleDataObject.material );
			return mesh;
		}
		else if(singleDataObject instanceof ThreeBSP)
			return new THREE.Mesh( singleDataObject.toGeometry(), default_material_meshFromThree );
		else if( singleDataObject instanceof verb.geom.NurbsSurface ){

			var geometry = singleDataObject.toThreeGeometry();

			if ( singleDataObject.material )
				return ( new THREE.Mesh( geometry, singleDataObject.material ) );
			else
				return ( new THREE.Mesh( geometry, default_material_meshFromVerbs ) );

		}
		else if( singleDataObject instanceof verb.geom.NurbsCurve ){
			console.log('nurbs curve detected');
			var geometry = singleDataObject.toThreeGeometry();

			if ( singleDataObject.material )
				return ( new THREE.Line( geometry, singleDataObject.material ) );
			else
				return ( new THREE.Line( geometry, default_material_lineFromVerbs ) );
		}
		else {
			console.log("Module doesnt recognise either!", singleDataObject);
		}
	}

	var rawResult = convertToThree( geom );
	var optimizedResult = /*changeLOD(0.2, */rawResult//); // run polychop on this and reduce the number of faces needs for the desired level of LOD

	optimizedResult.is_mObj = true;
	return optimizedResult;
}

//
// Takes convertedGeometry (three.js) from MobiusDataObjects and converts it to topology*
// Change content incase of change in Topology.js
//
var threeToTopology = function( convertedGeometry ){

	// conversion of topology
	if( convertedGeometry.constructor != Array ){
		var topo = new TOPOLOGY.createFromGeometry( convertedGeometry.geometry );
		return topo;
	}
	else{
		var topoArray = [];
		for(var geomNo = 0; geomNo &lt; convertedGeometry.length; geomNo++)
			topoArray.push( new TOPOLOGY.createFromGeometry( convertedGeometry[geomNo].geometry ) );
		return topoArray;
	}
}</code></pre>
=======
</code></pre>
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
        </article>
    </section>




</div>

<nav>
<<<<<<< HEAD
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addData">addData</a></li><li><a href="global.html#addMaterial">addMaterial</a></li><li><a href="global.html#addToFrame">addToFrame</a></li><li><a href="global.html#addToList">addToList</a></li><li><a href="global.html#averageList">averageList</a></li><li><a href="global.html#convertDegreesToRadians">convertDegreesToRadians</a></li><li><a href="global.html#convertRadiansToDegrees">convertRadiansToDegrees</a></li><li><a href="global.html#distanceBetweenTwoPoints">distanceBetweenTwoPoints</a></li><li><a href="global.html#divideCurveByArcLength">divideCurveByArcLength</a></li><li><a href="global.html#divideCurveByEqualArcLength">divideCurveByEqualArcLength</a></li><li><a href="global.html#extrudePolygon">extrudePolygon</a></li><li><a href="global.html#getAbsoluteValue">getAbsoluteValue</a></li><li><a href="global.html#getCentre">getCentre</a></li><li><a href="global.html#getCornerPointsFromSurface">getCornerPointsFromSurface</a></li><li><a href="global.html#getCrossProduct">getCrossProduct</a></li><li><a href="global.html#getDotProduct">getDotProduct</a></li><li><a href="global.html#getLength">getLength</a></li><li><a href="global.html#getListLength">getListLength</a></li><li><a href="global.html#getMaxValue">getMaxValue</a></li><li><a href="global.html#getMinValue">getMinValue</a></li><li><a href="global.html#getNormalAtSurfaceParameter">getNormalAtSurfaceParameter</a></li><li><a href="global.html#getPointFromPositionVector">getPointFromPositionVector</a></li><li><a href="global.html#getPointOnCurve">getPointOnCurve</a></li><li><a href="global.html#getPointOnSurface">getPointOnSurface</a></li><li><a href="global.html#getSignificantDigits">getSignificantDigits</a></li><li><a href="global.html#getTangentAtCurveParameter">getTangentAtCurveParameter</a></li><li><a href="global.html#indexOfObject">indexOfObject</a></li><li><a href="global.html#make2DRing">make2DRing</a></li><li><a href="global.html#makeArc">makeArc</a></li><li><a href="global.html#makeBezierCurve">makeBezierCurve</a></li><li><a href="global.html#makeBox">makeBox</a></li><li><a href="global.html#makeCircle">makeCircle</a></li><li><a href="global.html#makeCircleBoundary">makeCircleBoundary</a></li><li><a href="global.html#makeCopy">makeCopy</a></li><li><a href="global.html#makeCurveByKnotsControlPointsWeights">makeCurveByKnotsControlPointsWeights</a></li><li><a href="global.html#makeCurveByPoints">makeCurveByPoints</a></li><li><a href="global.html#makeCylinder">makeCylinder</a></li><li><a href="global.html#makeEllipse">makeEllipse</a></li><li><a href="global.html#makeEllipseArc">makeEllipseArc</a></li><li><a href="global.html#makeFrame">makeFrame</a></li><li><a href="global.html#makeLathe">makeLathe</a></li><li><a href="global.html#makeLine">makeLine</a></li><li><a href="global.html#makeMeshBySubdivision">makeMeshBySubdivision</a></li><li><a href="global.html#makePlane">makePlane</a></li><li><a href="global.html#makePoint">makePoint</a></li><li><a href="global.html#makePolygonByPoints">makePolygonByPoints</a></li><li><a href="global.html#makePolyhedron">makePolyhedron</a></li><li><a href="global.html#makePolyline">makePolyline</a></li><li><a href="global.html#makePositionVector">makePositionVector</a></li><li><a href="global.html#makePositionVectorsFromPoints">makePositionVectorsFromPoints</a></li><li><a href="global.html#makeSequence">makeSequence</a></li><li><a href="global.html#makeSphere">makeSphere</a></li><li><a href="global.html#makeSurfaceAsCone">makeSurfaceAsCone</a></li><li><a href="global.html#makeSurfaceAsCylinder">makeSurfaceAsCylinder</a></li><li><a href="global.html#makeSurfaceAsSphere">makeSurfaceAsSphere</a></li><li><a href="global.html#makeSurfaceByCorners">makeSurfaceByCorners</a></li><li><a href="global.html#makeSurfaceByExtrusion">makeSurfaceByExtrusion</a></li><li><a href="global.html#makeSurfaceByKnotsControlPointsWeights">makeSurfaceByKnotsControlPointsWeights</a></li><li><a href="global.html#makeSurfaceByLoft">makeSurfaceByLoft</a></li><li><a href="global.html#makeSurfaceByRevolution">makeSurfaceByRevolution</a></li><li><a href="global.html#makeSurfaceBySweep">makeSurfaceBySweep</a></li><li><a href="global.html#makeTetrahedron">makeTetrahedron</a></li><li><a href="global.html#makeTorus">makeTorus</a></li><li><a href="global.html#makeTorusKnot">makeTorusKnot</a></li><li><a href="global.html#makeTubeByLine">makeTubeByLine</a></li><li><a href="global.html#moveObjectToPoint">moveObjectToPoint</a></li><li><a href="global.html#objectIntersect">objectIntersect</a></li><li><a href="global.html#objectSubtract">objectSubtract</a></li><li><a href="global.html#objectUnion">objectUnion</a></li><li><a href="global.html#orientObjectTowards">orientObjectTowards</a></li><li><a href="global.html#rangeOfList">rangeOfList</a></li><li><a href="global.html#removeIndexFromList">removeIndexFromList</a></li><li><a href="global.html#rotateObject">rotateObject</a></li><li><a href="global.html#scaleObject">scaleObject</a></li><li><a href="global.html#shiftObject">shiftObject</a></li><li><a href="global.html#sumList">sumList</a></li></ul>
=======
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="crv.html">crv</a></li><li><a href="frm.html">frm</a></li><li><a href="lst.html">lst</a></li><li><a href="msc.html">msc</a></li><li><a href="mtx.html">mtx</a></li><li><a href="obj.html">obj</a></li><li><a href="pnt.html">pnt</a></li><li><a href="sld.html">sld</a></li><li><a href="srf.html">srf</a></li><li><a href="trn.html">trn</a></li><li><a href="vec.html">vec</a></li></ul>
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
</nav>

<br class="clear">

<footer>
<<<<<<< HEAD
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Fri Nov 20 2015 17:09:08 GMT+0800 (Malay Peninsula Standard Time)
=======
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Wed Dec 16 2015 04:42:04 GMT+0800 (Malay Peninsula Standard Time)
>>>>>>> 0e5eb81e0d11e91b292631103ddfe296fe4703bf
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
